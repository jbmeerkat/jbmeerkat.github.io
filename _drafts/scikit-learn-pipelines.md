---
layout: post
title: 'Конвейеры (pipelines) в scikit-learn: пример реального использования'
categories: machine-learning
tags: machine-learning scikit-learn pipelines
---

__План:__
- ~~Для чего нужны конвейеры~~
- ~~Что могут делать~~
- ~~Какие типы шагов существуют~~
- Интерфейс шагов и конвейера
- Решение задач с помощью конвейера
  - Разделение на обучение/тест/валидацию
  - Стандартизация/масштабирование признаков
  - Удаление пропусков
  - Кодирование разных типов признаков (категориальные/численные)
  - Отбор признаков
  - Обучение модели
  - Получение оценок/метрик/прогноза
- Полноценный пример конвейера со всеми этими шагами максимально приближенный к реальной жизни

_Отметить момент с порядком разбиения и масштабирование/стандартизацией https://machinelearningmastery.com/data-preparation-without-data-leakage_

__Оглавление__
- [Цель статьи](#why)
- [Терминология](#terminology)
- [Для чего нужен pipeline](#purpose)
- [Какие шаги есть в pipeline](#steps)
- [Интерфейс шагов и pipeline](#interfaces)


## <a href="#why">Цель статьи</a>

Разных материалов достаточно много, но у всех есть недостатки (не буду их перечислять). Хочется написать статью,
которая хорошо и понятно объяснит как использовать pipeline из библиотеки scikit-learn на примерах,
максимально близких к реальной жизни используя лучшие практики.


## <a href="#terminology">Терминология</a>

В русском сообществе машинного обучения как только не говорят, но чаще всего используют прямые заимствования
английских терминов: пайплайн, трансформер, эстиматор (это которые estimator из scikit-learn). Хороших устоявшихся
русских терминов я не знаю и поэтому буду использовать исходные термины: pipeline, transformer, estimator.


## <a href="#purpose">Для чего нужен pipeline</a>

Обычно приходится делать похожие вещи: подготовка признаков, отбор, нормализация, обучение, оценка. Pipeline
помогает объединить эти шаги в понятную и удобную структуру, которую можно использовать, например, в
перекрестной проверке (cross-validation) или подборе параметров (например, grid search).

Ещё pipeline может кешировать результаты вычисления промежуточных шагов за счет этого сильно ускоряя
работу при множественных запусках.

Да и если приходилось когда-нибудь страдать от того, что в какой-то момент код так раскидан по тетрадке, что любое
изменение становится болью, а перезапуск всей тетрадки приводит к ошибкам — pipeline может помочь (но это не точно).


## <a href="#steps">Какие шаги есть в pipeline</a>

Все промежуточные шаги обязательно должны быть пребразованиями (transformer), последний может быть estimator (про это позже),
например, классификатор.


## <a href="#interfaces">Интерфейс шагов и pipeline</a>

Итого, действующих лиц у нас может быть два (если нужно только преобразовать данные) или три (если нужно обучение):
- Pipeline
- Transformer (произвольное количество)
- Estimator (опционально)

Начнем с pipeline, так как то, что мы от него хотим отчасти определяет интерфейс остальных компонентов.

__Pipeline__ — у него достаточно обширный интерфейс ([документация, подзагловок Methods](https://scikit-learn.org/1.0/modules/generated/sklearn.pipeline.Pipeline.html)),
но в простом случае нас интересует `transform` и `fit`.

__Transformer__ — это объект, у которого есть методы `fit` и `transform`.

__Estimator__ — объект, у которого есть метод `fit`.


